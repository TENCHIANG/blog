### JVM三个内存区

* 栈区 stack
  * 方法执行：每个方法的调用都创建一个栈帧
  * 线程管理：每个线程创建一个栈 
  * 栈是线程私有的
  * 连续的内存空间，系统自动分配，速度快
* 堆区 heap
  * 存放创建好的对象（如数组）
  * JVM只有一个堆（线程共享）
  * 不连续的内存空间，分配灵活，速度慢
  * 只要是在堆里面的**默认值就是0**
* 方法区 method area（静态堆）
  * JVM只有一个方法区（线程共享）
  * 方法区也是堆，只用来存放不变或者唯一的内容
    * 类信息（Class对象）
    * 静态变量
    * 字符串常量

### 构造方法

* 也叫构造器，constructor，用于创建和初始化对象
* 构造方法通过 new 关键字调用
* 构造方法不能定义返回值类型
  * 构造方法内不能使用可以单独使用 return 结束方法 但是不能让 return 返回值
  * 因为返回值是确定的，就是指定类的对象
* 如果没有定义构造器，编译器会定一个无参的构造方法（反之相反）
  * 如果自己定义，编译器就不会自动添加
* 构造器的方法名须和类名一致
* 构造方法的第一句总是 **super()**

### 垃圾回收 Garbage Collection

* 发现无用对象
* 回收无用对象占用的空间

#### 垃圾回收算法

* 引用计数法
  * 缺点：循环引用的无用对象
* 引用可达法（搜索算法）
  * 把引用关系看做一张图
  * 从 GC ROOT 节点开始，寻找对应的引用节点
  * 找到节点后，继续寻找该节点的引用节点
  * 所有的引用节点找到后，剩余的节点就是无用节点（没有被引用）

```java
// 循环引用
public class Student {
    String name;
    Student friend;
    
    public static void main (String[] args) {
        Student s1 = new Student();
        Student s2 = new Student();
        
        s1.friend = s2;
        s2.friend = s1;
        
        s1 = null;
        s2 = null;
    }
}
```

#### 分代垃圾回收

* 不同对象生命周期不一样，用不一样的回收算法
* 对象分三种状态
  * 年轻代
  * 年老代
  * 持久代
* JVM将堆内存划分为
  * Eden（Minor GC）
  * Survivor（Major GC、Full GC）
  * Tenured/Old

