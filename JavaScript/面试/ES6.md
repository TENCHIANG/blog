let是声明变量，const是声明常量，两个都有块级作用域，const声明之后必须赋值，否则会报错

async 是用于申明一个 function 是异步的，而await 用于等待一个异步方法执行完成

import导入模块、export导出模块

**class、extends(继承)、super**  class定义类，不同的类之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承要简单太多了。比如说啊，我现在随便定义一个类名叫什么呢........就叫大写开头的Abb把，里边有个constructor方法，也就是构造方法，这个跟ES5里边的函数原型对象里的constructor概念其实差不多；constructor里边的this关键字在这里边就代表实例对象。简单来讲，constructor里面定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。那个super关键字，它就是指代父类的实例（也就是父类的this对象）。    子类是必须肯定且一定要在constructor方法中调用super方法，否则新建实例时会报错。  （ 因为子类没有自己的this对象的，他是继承的他爸爸的this对象。如果不调用super方法的话，子类就得不到this对象）。    ES6的继承机制，其实就是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。

**箭头头函数**不需要 function 关键字来创建函数，可以省略 return 关键字，继承当前上下文的 this 关键字嘛，函数有且仅有一个参数的时候，是可以省略掉括号的；当函数中有且仅有一个表达式的时候可以省略{}。

对象函数简写。可以省掉function

解构赋值

...展开运算符

Promise用同步的方式去写异步代码

Generators 迭代器   最直观的表现就是比普通的function多了个星号，里边可以用y开头的关键字，叫啥来着，叫yield吧，函数会在每个yield后暂停，不好意思哦，我可能念的不太好。这玩意儿就像是在银行办手续取票，我取了票，挺住，等你点取票，它再出票。异步的时候可以用，但是一般情况还是使用async。

