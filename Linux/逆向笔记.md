## 逆向笔记

### 逆向工具

* apktool、AndroidKillwe、jd-gui、IDA

### apktool 解包工具

```sh
apktool d test.apk # 解包
apktool b test -o test_crack.apk # 重打包
```

* 然后再使用 AndroidKillwe 进行签名
* [《教我兄弟学Android逆向番外01 apktool的使用》 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn](https://www.52pojie.cn/thread-732007-1-1.html)

### 安卓平台

* armeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它
* arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一
* armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多
* x86: 平板、模拟器用得比较多
* x86_64: 64位的平板

### CE：Cheat Engine

* 建议选择CE6.4.3风叶人加强版
* 设置 - 扫描设置 - 扫描以下内存区域 - 全部勾选
* 设置 - 调试器选项 - 调试器方法 - 使用 VEH 调试器
* 模拟器的话一般选择Headless或者Handle之类的无头模拟器进程
* 扫描选项：全面（预设）、全面（极端）、简化（说的是扫描的精度，选择**简化**即可）
* 地址清单 - 右键 - 浏览相关内存区域 **Ctrl+B**
  * 右键 - 显示类型 - 4字节十进制
  * 最好一行四个地址显示，方便查看
  * 在这里可以复制特征码
* 地址清单批量改名：Ctrl/Shift+右键选择地址，**Ctrl+Enter**批量改名
* 整形在内存中的表示：
  * 1000 0x000003e8
  * 内存中的表示：e8 03 00 00
* **内存特征码**：在目标内存的附近，选出**不变**的一段字节，作为特征码，先找特征码，然后根据偏移定位到目标（准确+快速）
  * 进程id
  * 搜索类型：1返回值 2返回地址
  * 机器码：特征码（如"60 91 E3 40 68 16 8B 85 FB FF FF FF"，也可以不加空格）
  * 机器码位置：0
  * 起始地址："10000000"（特征码前面）
  * 结束地址："9fffffff"
  * 大小：4096、40960、[409600]（内存分页、**内存对齐**）
    * 4字节对齐（4K对齐，32位）
    * 8字节对齐（64位）
    * 效率和准确度成反比
    * 大漠插件 FindDataEx 的第四个参数（4）
  * 以上是易语言 `内存读写_特征码搜索`的参数（返回文本类型）
    * 找到的特征码可能**多个**（特征码重复），注意看哪个是对的
  * **代码实现**的话，用特征码比较多（而不是写死）
  * **特征码最佳实践**：找特征码 - 找基准目标 - 找其它很多目标
* **内存数据对比**：
  * 多个模拟器，多个CE，搜索同一个数据，提取相同的特征码（更精准）
  * 提取特征码的时候可以用**16进制1字节**显示，能更好的查看变化
  * **0也可以作为特征码之一**，前提是前后都要有数据（**不要全选全0或者全F的，容易重复**）
  * 防止重启更新、防止游戏更新
* 特征码某些字节发生改变：**特征码通配符**
  * 一个字节变化：??
  * 使用**文本对比工具**找出不同的地方，然后替换为通配符（普特文本比较器）
  * 也可以用文本对比工具找出相同的，作为特征码
* **特征码工具**（类人猿特征码工具）
  * 方法思路比答案更重要
  * 特征码离目标数据远（CE就不方便，不过可以用CE大致看看，然后再用特征码工具）
  * 模拟器ID1：选择第一个模拟器，然后点击该按钮获取其PID
    * 开始地址填目标数据在第一个模拟器的地址，下同
  * 模拟器ID2：选择第二个模拟器，然CE后点击该按钮获取其PID
    * 开始地址填目标数据在第一个模拟器的地址，与上一个**不一定相同**
  * 选择目标数据的数据类型（CE）
  * 遍历次数：500（查找数据的行数）
  * 选择**加**或者**减**
    * 加：往下找（要减回去）
    * 减：往上找（要加回去）
    * 加减都试一下找到好的特征码（注意符号）
  * 点击**一键遍历**
  * 点击**对比数据**
    * **对比后数据**、**十六字节**字段为空则说明不一样，不为空说明一样
    * 双击**十六字节**字段，添加到结果框（特征码）
    * 或者特征序号开始、特征结束序号（填序号），然后**一键提取特征码**
  * **距离**字段：距离目标的绝对距离（加法则减，减法则加）
  * 直接在工具里找**其他目标数据**
    * 关键字：目标数据的值
    * 列：目标数据值所在列（从0开始）
    * 一般只要特征码对了就没毛病
    * 搜不到就调整**加减**和**遍历次数**
    * 这时候找到的距离不用做任何修改（因为是基于基准目标而不是特征码的）
      * 基准目标数据基于特征码 - 其它目标数据基于基准目标
* 特征码工具功能解析
  * 模拟器进程获取
  * 模拟器内存数据遍历
  * 数据对比获取特征码
  * 64位的模拟器要用**长整型**
* 大漠插件读取内存
  * 收费版7.8以上
* **内存属性**：r、w、x、wx、rwx
* **游戏坐标数据技巧**
  * 在**不加密**的情况下
    * 3D游戏的坐标一般是**单精度**浮点数或**双精度**浮点数
    * 2D游戏也有可能是**整数**
  * XYZ坐标在内存中一般是**相邻**的，相隔4~8字节
  * 坐标搜索不到可能是显示坐标和实际坐标的**偏差**（显示52，真实可能是+-1）
    * 一般扫描类型选择**精确数值**+**简化**
    * 扫描类型可以试试**两者之间的数值**
    * 中间也可以通过扫描类型设置为**未变动的数值**来筛选
  * **不显示坐标**（工作量大）
    * 扫描类型：未知的初始值（初次），变动的数值（再次）
    * 数值类型：浮点数
    * 对于其它不显示的数据也同理，先猜数值类型再不断扫描
* **如何判断两个模拟器的地址是对应的**
  * 数据不一定是一一对应的，甚至**顺序**都不一定是一致的
  * 打开CE内存区域分析匹配
  * 修改内存数据，观察是否变化（找到那个可以引发变化的数据）
    * 先确定X点，然后通过偏移确定Y点
    * CE：选择x点**复制**，然后点空白处**粘贴**，在**Text to find**输入Y点名称，在右边**Adjust addres by**输入偏移（0不改变正数为加负数为减），粘贴后可以通过显示的数值和走动验证其正确性
* 整数型**联合搜索**法（GG）
  * 选择两个非0且不重复的特征码，点击特征码工具的**联合搜索数据**
  * 搜第一个特征码，然后用第二个特征码**筛选**（用来筛选的也可不止一个）
  * 得到第一个数据的内存地址（第一个特征码，然后再通过**偏移**取目标数据）
* 浮点数**联合搜素**
  * **浮点搜索其实是模糊搜索**（误差）
  * 搜第一个浮点型特征码时，用范围搜索
  * 用第二个特征码筛选时，也不要用等号，要用大于小于号（也是范围）
  * 用什么**范围**呢：用**小数最后一位 +-1**（如3.14就要用3.13和3.15）
* **搜索字符串**
  * 扫描类型：搜索文字
  * 数值类型：字串
  * 根据实际情况区分大小写
  * 先不搜Unicode，再搜Unicode
* 游戏**人物ID**分析（搜索字符串）
  * 组成：区服务器+职业+性别+...
  * 用人物ID本身提取特征码，然后搜索人物ID本身（**自身提取特征码**）
* 人物名字的搜索与修改
  * CE版本**6.7**以上
  * 搜索字符串时选择UTF-16，即Unicode（不打勾即为UTF-8）
  * 模拟器外搜索的是**虚拟数据**，不直接支持结构体字符串指针的
* 注入寻路call（注入so文件）
  * C语言、Java、JNI、ARM汇编分析、smali代码逆向分析、加壳脱壳、、、
  * 技术含量高
  * 易语言没有能力写成apk直接注入
* 触发游戏自带的寻路call（退而求其次）
  * 寻路数据：目标的坐标（非当前坐标）
  * 通过目标NPC的坐标搜索
  * 通过输入游戏目标坐标搜索
  * 通过走路的目的地坐标搜索（大概坐标范围值、数据量大）
  * **锁定**：循环写入（多个数据一般要同时修改才生效）
  * 可能要要有个**状态值**：如0正常、1寻路
* **混合型联合搜索**
  * finddata+其他地址对比
  * 多特征码搜索+联合搜索筛选（提取联合距离）
    * 多特征码搜索不止一个结果
    * 特征序号开始：第一个特征码
    * 特征结束序号：找一个筛选码
    * 点击**联合搜索数据**（此时已经可以看到筛选码对于第一个特征码的偏移了）
      * 把中间的删掉
      * 点击**提取联合距离**
  * 目标就是只留一个结果
* **获取NPC ID**
  * NPC ID是不显示的（跟上面的坐标搜索差不多）
  * 扫描类型：
    * 未知的初始数值（首次）
    * 变动的数值（再次）
    * 精确数值0（不选中NPC）
    * 变动的数值（再次选中NPC）
    * 未变动的数值（不改变选中的NPC）
    * 两者之间的数值 0~1000（选中时从1开始，没选中从0开始，也可以到10000）
    * 上面的方法多试几次，筛选到两个模拟器分别只有一两个，然后打开内存范围筛选出相似的再去弄特征码
  * 数值类型：4字节
  * **显示数据和控制数据是不一样的**

### GG：Game Guardian

* 安装GG后有两个图标：HW和SW，硬件加速和软件加速，打开GG后主页有介绍
* 搜索范围就搜 A 即可，最多加个 Ca
* 紫色的地址代表**指针**
* CE搜索到的内存地址和GG不一样
* GG查找的是安卓内部的**真实地址**（更快速），CE查的是相对于PC端的**虚拟地址**（模拟器黑盒）
  * GG和CE的地址暂时还无法互相转换
* GG的劣势：特征码得手动找，没有Win方便的工具
* CE不能通过**找出是什么访问/写入了这个地址**来找地址（端游的逻辑）
* **指针+偏移找基址**（按键精灵）
  * 打开两个模拟器
  * 在数据结果中搜索其指针（长按，**跳转到指针**）
    * 偏移量：1k、1w、10w的试
    * 勾选16进制
    * 类型：Dword（4字节整数类型）
    * 会查到很多个，需要和另一个的搜索结果对比，选比较像的那两个（一边一个）
      * 记录下来这个指针的地址，并算出与数据的偏移
      * 再往上找，找到两个模拟器有很多相同的，第一个就是**基地址**（一般就找2~3层）
      * 基地址保存的值转为十六进制（也是个地址），计算出与上一层指针的偏移
      * **基地址 --> 结构体指针 --> 数据 --> 其它数据（从数据开始找）**
        * 基地址存的指针在结构体指针附近
      * 要反复确认对比起结果的正确性

```basic
Dim pkg = sys.GetFront()
Dim base = 基地址 // "0x40947bf8"
Dim val = Sys.MemoryRead(pkg, base, "u32") // 取指针值
TracePrint(pkg)

val = hex(val)
val = Sys.MemoryRead(pkg, change(val, 指针偏移), "u32") // 取指针值
TracePrint(val)

val = hex(val)
val = Sys.MemoryRead(pkg, change(val, 数据偏移), "i32") // 取数据值
TracePrint(val)

Function change (addr, offset)
    change = hex(Clng(addr) + offset)
End Function

Function hex (number)
    hex = "0x" & Hex(number)
End Function
```

### 易语言与按键精灵通讯

* 易语言只能在Windows上运行
* 安卓内部由 安卓助手（按键精灵） **客户端**
  * 紫猫插件（TCP）
* 安卓外部做 **服务端**
  * 服务器控件+精易模块

### IDA

* 打开 so 文件后，注意是否已经全部反汇编完（ARM汇编）
* 在IDA VIEW-A界面，按空格进入流程图模式
  * 蓝色线代表顺序执行流程
  * 红色先代表分支流程的条件假
  * 蓝色代表条件真
* IDA不是所有函数都能识别出来（sub_ffffff 内存相对偏移地址）
* loc_ffffff 跳转相关
* 打开字符串窗口：View - Open subviews - Strings（Shift+F12）

### CE设置最佳实践

* Extra
  * Query memory region routines
  * Read/Write Process Memory (Will cause slower scans)
  * Open Process
* Debugger Options
  * Debugger method
    * Use VEH Debugger
    * Use windows debugger（默认）
    * Use kernelmode debugger（Requires DBVM）